// === FormRepository.java ===
package com.yourproject.repository;

import com.yourproject.model.Form;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface FormRepository extends MongoRepository<Form, String> {
}

// === ResponseRepository.java ===
package com.yourproject.repository;

import com.yourproject.model.Response;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ResponseRepository extends MongoRepository<Response, String> {
    Optional<Response> findByFormIdAndUserId(String formId, String userId);
}

// === Response.java ===
package com.yourproject.model;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.util.List;

@Data
@Document(collection = "responses")
public class Response {
    @Id
    private String id;
    private String formId;
    private String userId;
    private List<Answer> answers;
}

// === Answer.java ===
package com.yourproject.model;

import lombok.Data;

@Data
public class Answer {
    private String questionId;
    private Object response;
}

// === Updated UserController.java ===
package com.yourproject.controller;

import com.yourproject.model.Answer;
import com.yourproject.model.Form;
import com.yourproject.model.Response;
import com.yourproject.repository.FormRepository;
import com.yourproject.repository.ResponseRepository;
import lombok.Data;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private FormRepository formRepo;

    @Autowired
    private ResponseRepository responseRepo;

    // Get assigned forms
    @GetMapping("/forms/assigned")
    public ResponseEntity<List<Form>> getAssignedForms(Authentication authentication) {
        String employeeId = authentication.getName();
        List<Form> forms = formRepo.findAll().stream()
            .filter(f -> f.getTargetUserIds() != null && f.getTargetUserIds().contains(employeeId))
            .collect(Collectors.toList());

        return ResponseEntity.ok(forms);
    }

    // Submit or update response
    @PostMapping("/forms/{formId}/submit")
    public ResponseEntity<?> submitResponse(@PathVariable String formId, @RequestBody SubmitRequest req, Authentication authentication) {
        String employeeId = authentication.getName();
        Optional<Form> optionalForm = formRepo.findById(formId);
        if (optionalForm.isEmpty()) return ResponseEntity.notFound().build();

        Response response = responseRepo.findByFormIdAndUserId(formId, employeeId).orElse(new Response());
        response.setFormId(formId);
        response.setUserId(employeeId);
        response.setAnswers(req.getAnswers());

        responseRepo.save(response);
        return ResponseEntity.ok("Response submitted successfully");
    }

    // Check if user already submitted response for the form
    @GetMapping("/forms/{formId}/submitted")
    public ResponseEntity<Boolean> isFormSubmitted(@PathVariable String formId, Authentication authentication) {
        String employeeId = authentication.getName();
        boolean submitted = responseRepo.findByFormIdAndUserId(formId, employeeId).isPresent();
        return ResponseEntity.ok(submitted);
    }

    @Data
    public static class SubmitRequest {
        private List<Answer> answers;
    }
}
// === FillAssignedForm.jsx ===
// === FillAssignedForm.jsx ===
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import API from '../api/api';

export default function FillAssignedForm() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [form, setForm] = useState(null);
  const [answers, setAnswers] = useState([]);
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    API.get(`/api/user/forms/assigned`)
      .then(res => {
        const foundForm = res.data.find(f => f.id === id);
        if (foundForm) setForm(foundForm);
        else console.error("Form not found in assigned list");
      })
      .catch(err => console.error("Error fetching assigned forms", err));

    API.get(`/api/user/forms/${id}/submitted`)
      .then(res => setSubmitted(res.data))
      .catch(() => {});
  }, [id]);

  const handleChange = (qid, value, isMulti) => {
    setAnswers(prev => {
      const updated = [...prev];
      const index = updated.findIndex(a => a.questionId === qid);
      if (index !== -1) {
        updated[index].answer = isMulti ? value : [value];
      } else {
        updated.push({ questionId: qid, answer: isMulti ? value : [value] });
      }
      return updated;
    });
  };

  const handleMultiChange = (qid, val) => {
    const current = answers.find(a => a.questionId === qid)?.answer || [];
    const newSet = new Set(current);
    newSet.has(val) ? newSet.delete(val) : newSet.add(val);
    handleChange(qid, Array.from(newSet), true);
  };

  const handleSubmit = async () => {
    try {
      await API.post(`/api/user/forms/${id}/submit`, { answers });
      setSubmitted(true);
    } catch (err) {
      console.error("Error submitting form", err);
      alert("Submission failed. You may not have access.");
    }
  };

  if (!form) return <div className="p-6">Loading...</div>;

  if (submitted) {
    return (
      <div className="p-8 text-center">
        <h2 className="text-2xl text-green-600 font-bold mb-4">Form Already Submitted ✅</h2>
        <button onClick={() => navigate('/user')} className="text-blue-700 underline">
          Go Back
        </button>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-blue-900 text-white px-6 py-4 shadow">
        <h1 className="text-xl font-semibold">Coforge Feedback Form</h1>
      </header>

      <main className="max-w-3xl mx-auto p-8">
        <h2 className="text-3xl font-bold mb-4 text-blue-900">{form.title}</h2>
        <p className="mb-6 text-gray-600 italic">{form.description}</p>

        {form.question.map(q => (
          <div key={q.id} className="mb-6 bg-white p-4 rounded shadow">
            <label className="block font-semibold mb-2">{q.text}</label>

            {q.type === 'SHORT_ANSWER' && (
              <input
                type="text"
                onChange={e => handleChange(q.id, e.target.value)}
                className="w-full border p-2 rounded"
              />
            )}

            {q.type === 'LONG_ANSWER' && (
              <textarea
                rows="4"
                onChange={e => handleChange(q.id, e.target.value)}
                className="w-full border p-2 rounded"
              />
            )}

            {q.type === 'MULTIPLE_CHOICE' && (
              <div className="space-y-2">
                {q.options.map(opt => (
                  <label key={opt} className="flex gap-2">
                    <input
                      type="radio"
                      name={`q-${q.id}`}
                      value={opt}
                      onChange={() => handleChange(q.id, opt)}
                    />
                    {opt}
                  </label>
                ))}
              </div>
            )}

            {q.type === 'MULTI_SELECT' && (
              <div className="space-y-2">
                {q.options.map(opt => (
                  <label key={opt} className="flex gap-2">
                    <input
                      type="checkbox"
                      value={opt}
                      onChange={() => handleMultiChange(q.id, opt)}
                    />
                    {opt}
                  </label>
                ))}
              </div>
            )}
          </div>
        ))}

        <button
          onClick={handleSubmit}
          className="bg-blue-900 text-white px-6 py-2 rounded hover:bg-blue-800"
        >
          Submit Response
        </button>
      </main>
    </div>
  );
}

// === AssignedForms.jsx ===
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import API from '../api/api';

export default function AssignedForms() {
  const [forms, setForms] = useState([]);
  const nav = useNavigate();

  useEffect(() => {
    API.get('/api/user/forms/assigned')
      .then(res => setForms(res.data))
      .catch(err => console.error("Failed to fetch assigned forms", err));
  }, []);

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-blue-900 text-white px-6 py-4 shadow-md flex items-center gap-4">
        <img src="/assets/coforge-logo.png" alt="Coforge" className="h-10" />
        <h1 className="text-xl font-bold">Assigned Feedback Forms</h1>
      </header>

      <main className="p-8 max-w-3xl mx-auto">
        <h2 className="text-2xl font-semibold mb-4 text-blue-900">Your Assigned Forms</h2>
        {forms.length === 0 ? (
          <p className="text-gray-700">No forms assigned to you at the moment.</p>
        ) : (
          <ul className="space-y-2">
            {forms.map(f => (
              <li key={f.id} className="flex items-center justify-between bg-white p-4 rounded shadow">
                <span className="text-blue-900 font-medium">{f.title}</span>
                <button
                  onClick={() => nav(`/user/fill/${f.id}`)}
                  className="text-blue-700 underline hover:text-blue-900"
                >
                  Fill Now
                </button>
              </li>
            ))}
          </ul>
        )}
      </main>
    </div>
  );
}
// === api.js ===
import axios from 'axios';

const API = axios.create({
  baseURL: 'http://localhost:8080', // Replace with your actual backend URL
  withCredentials: true,
});
//api.js//////
// === api.js ===
import axios from 'axios';

// Create base API instance
const API = axios.create({
  baseURL: 'http://localhost:8080', // 🔁 Change if needed
});

// Request Interceptor to add token
API.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  error => Promise.reject(error)
);

// Response Interceptor to handle 401 / 403 errors
API.interceptors.response.use(
  response => response,
  error => {
    if (error.response && (error.response.status === 401 || error.response.status === 403)) {
      // Token expired or unauthorized access
      alert("Session expired or unauthorized. Please login again.");
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default API;


//mongosh
// Required for UUID generation
function generateUUID() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11)
    .replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
}

// Only needed in mongosh or environments without crypto
if (typeof crypto === 'undefined') {
  global.crypto = require('crypto').webcrypto;
}

db.forms.find().forEach(form => {
  let modified = false;

  form.question = form.question.map(q => {
    if (!q.id || typeof q.id !== 'string' || q.id.startsWith("q-") || q.id === "undefined") {
      q.id = generateUUID();
      modified = true;
    }
    return q;
  });

  if (modified) {
    db.forms.updateOne({ _id: form._id }, { $set: { question: form.question } });
    print(`✅ Updated form: ${form._id}`);
  }
});
///fix
db.forms.find({ "question.id": { $exists: false } }).count();
//the targetids one 
public class FormCreationRequest {
    private String title;
    private String description;
    private List<Question> question;
    private List<String> targetEmails; // <-- changed from targetUserIds

    // getters and setters
}
//admincontroller 
@PostMapping("/forms/create")
public ResponseEntity<?> createForm(@RequestBody FormCreationRequest req) {
    Form form = new Form();
    form.setTitle(req.getTitle());
    form.setDescription(req.getDescription());
    form.setQuestion(req.getQuestion());

    // Assign by email
    List<User> targetUsers = userRepository.findByEmailIn(req.getTargetEmails());
    form.setTargetUsers(targetUsers);

    formRepository.save(form);

    return ResponseEntity.ok("Form created and assigned via emails");
}
